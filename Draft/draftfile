#Choose the port and host of each ’server’.`
http 
    index #index.php index.htm index.html
    Server
        - name:
        - host:
        - port:
        - root: #default #/var/www/site
        - methods:
        - redirection:
        - searchDir:
        - Location : #/xxx/xx
            #directorListing
            - autoIndex: on/off
#The first server for a host:port will be the default for this host:port (that means
#it will answer to all the requests that don’t belong to an other server).
defaultErrorPages
    - 404:
    - ...:
#Limit client body size.
    - bodyBufferSize:

___

  - server: # server
      server_name: 127.0.0.1
      listen: 8080

      root: /Users/ashite/Desktop/webserv/root/php-website

      client_max_body_size: 1000
      locations:
          - /:
              auto_index: true
              index:
                - index.html
                - index.htm
                - index.php
              error_page:
                - code: 500
                  content: ./Networking/index.html
                - code: 502
                  content: ./Networking/index.html
              upload_directory: /var/www/html/public/uploads
              allowed_methods:
                - POST
                - GET
                - DELETE
              cgi:
                #make sure you have php-cgi installed on your system
                # put the php-cgi absolute path here
                path: /Users/ashite/.brew/bin/php-cgi

                ext:
                  - .php
                  - .php5
                  - .php7
                  - .php-cgi
                  - .php3
                  - .php4
                  - .php5
                  - .php6
_____

#include <iostream>
#include "Karen.hpp"

Karen::Karen()
{
	this->indexMessage[0] = "DEBUG";
	this->indexMessage[1] = "INFO";
	this->indexMessage[2] = "WARNING";
	this->indexMessage[3] = "ERROR";

	this->message[0] = &Karen::debug;
	this->message[1] = &Karen::info;
	this->message[2] = &Karen::warning;
	this->message[3] = &Karen::error;
}

void	Karen::debug()
{
	std::cout << "I love to get extra bacon for my 7XL-double-cheese-triple-pickle-special-ketchup burger. I just love it!" << std::endl;
}

void	Karen::info()
{
	std::cout << "I cannot believe adding extra bacon cost more money. You don’t put enough! If you did I would not have to ask for it!" << std::endl;
}

void	Karen::warning()
{
	std::cout << "I think I deserve to have some extra bacon for free. I’ve been coming here for years and you just started working here last month." << std::endl;
}

void	Karen::error()
{
	std::cout << "This is unacceptable, I want to speak to the manager now." << std::endl;
}

void	Karen::complain(std::string level)
{
	int	i = 0;
	while (i <= 3)
	{
		if (level == this->indexMessage[i])
		{
			//std::cout << this->indexMessage[i] << std::endl;
			(this->*message[i])();
		}
		i++;
	}
}
_____
#pragma once
#ifndef _KAREN_H
#define _KAREN_H

#include <iostream>
#include <string>

class Karen
{
	public:
		Karen();
		std::string	indexMessage[4];
		void	(Karen::*message[4])(void);
		void	complain(std::string level);
	
	private:
		void	debug(void);
		void	info(void);
		void	warning(void);
		void	error(void);
};

#endif



            while (getline(ifs, line) && token == "server:")
            {
                if (!isComment(line))
                {
                    //skip empty spaces
                    skipSpaces(line);
                    
                    std::stringstream Y(line);
                    getline(Y, token,' ');
                    previousKey = token;
                        
                    if (status == "server:" && token != "server:")
                    {
                        for (int    j = 0; j < 7; j++)
                        {
                            if (token == (this->_keys)[j])
                                (this->*t_directiveParser[j])(status, line, root);
                        }
                    }
                }
            }

                    else if (status =="server:")
                    {
                        // looking for a way to parse server and push it into the root
                        server = &root.get_server(serverCounter);
                        //look for comments
                        i = 7;
                        while ((line[i] == 32 || (line[i] < 14 && line[i] > 8))&& i< line.length())
                            i++;
                        if (line[i] && line[i] != '#')
                        {
                            std::cout << "|"<< "FUCK OFF" << "|"<<std::endl;
                            exit(1);
                        }
                        for (int    j = 0; j < 13; j++)
                        {
                            if (token == (this->_keys)[j])
                                (this->*t_directiveParser[j])(status, line, root);
                        }
                        /* code */
                    }
                    else if (status == "location")
                    {

                    }
                    else if (previousKey == "server:")
                    {
                        Server server = new Server();
                        status = "server:";
                        serverCounter++;
                    }    
                    else
                    {
                        std::cout << "|"<< "FUCK OFF" << "|"<<std::endl;
                        exit(1);
                    }
                }
            }
        }
        else
        {
            std::cout << "|"<< "FUCK OFF" << "|"<<std::endl;
            exit(1);
        }
    }
    return 0;
}